<!DOCTYPE html>
<html>
<head>
    <title>Water Delineation service</title>
    <script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="http://openlayers.org/en/v3.11.2/css/ol.css" type="text/css">
    <script src="http://openlayers.org/en/v3.11.2/build/ol.js"></script>
    <script src='http://watersgeo.epa.gov/WATERS/tools/WATERSServicesJSLib/WATERSServices-1.0.0.js'></script>
    <script src='http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js'></script>

</head>
<body>
    <div class="container-fluid">

        <div class="row-fluid">
            <div class="span12">
                <div id="map" class="map"></div>
            </div>
        </div>

        <a name="btnDownload" class="btn btn-default" id="waterDelin" onclick="run_navigation_delineation_service()">
            <span class="glyphicon hydroshare" aria-hidden="true"></span>Delineate Watershed
        </a>
        <div id="delineation_output"></div>
    </div>


    <script>

var layer = [
  new ol.layer.Tile({
			source: new ol.source.BingMaps({
				imagerySet: 'AerialWithLabels',
				key: 'Ak-dzM4wZjSqTlzveKz5u0d4IQ4bRzVI309GxmkgSVr1ewS6iPSrOvOKhA-CJlm3'
			})
  }),
];

var map = new ol.Map({
  layers: layer,
  target: 'map',
  view: new ol.View({
    center: [-10997148, 4569099],
    zoom: 4
  })
});

var start_point_layer, click_point_layer, end_point_layer, indexing_path_layer, flow_lines_layer;
var basin_layer, streams_layer;

click_point_layer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: new ol.style.Style({
            fill: new ol.style.Fill({
                color: 'rgba(255, 255, 255, 0.2)'
            }),
            stroke: new ol.style.Stroke({
                color: '#ffcc33',
                width: 2
            }),
            image: new ol.style.Circle({
                radius: 7,
                fill: new ol.style.Fill({
                    color: '#ffcc33'
                })
            })
        })
    })

start_point_layer = new ol.layer.Vector({
	source: new ol.source.Vector(),
	style: new ol.style.Style({
		fill: new ol.style.Fill({
			color: 'rgba(255,100,100,0.6)'
		}),
		stroke: new ol.style.Stroke({
			color: '#ffccff',
			width: 2
		}),
		image: new ol.style.Circle({
			radius: 5,
			fill: new ol.style.Fill({
				color: '#ffccff'
			})
		})
	})
});

end_point_layer = new ol.layer.Vector({
	source: new ol.source.Vector(),
	style: new ol.style.Style({
		fill: new ol.style.Fill({
			color: 'rgba(255,100,100,0.6)'
		}),
		stroke: new ol.style.Stroke({
			color: '#00ccff',
			width: 2
		}),
		image: new ol.style.Circle({
			radius: 5,
			fill: new ol.style.Fill({
				color: '#00ccff'
			})
		})
	})
});

indexing_path_layer = new ol.layer.Vector({
	source: new ol.source.Vector(),
	style: new ol.style.Style({
		fill: new ol.style.Fill({
			color: 'rgba(255,100,100,0.6)'
		}),
		stroke: new ol.style.Stroke({
			color: '#00cc00',
			width: 2
		}),
		image: new ol.style.Circle({
			radius: 5,
			fill: new ol.style.Fill({
				color: '#00cc00'
			})
		})
	})
});

flow_lines_layer = new ol.layer.Vector({
	source: new ol.source.Vector(),
	style: new ol.style.Style({
		fill: new ol.style.Fill({
			color: 'rgba(0,0,255,0.6)'
		}),
		stroke: new ol.style.Stroke({
			color: '#0000ff',
			width: 2
		}),
		image: new ol.style.Circle({
			radius: 5,
			fill: new ol.style.Fill({
				color: '#0000ff'
			})
		})
	})
});

basin_layer = new ol.layer.Vector({
	source: new ol.source.Vector(),
	style: new ol.style.Style({
		fill: new ol.style.Fill({
			color: 'rgba(0,0,255,0.2)'
		}),
		stroke: new ol.style.Stroke({
			color: '#0000ff',
			width: 2
		}),
		image: new ol.style.Circle({
			radius: 5,
			fill: new ol.style.Fill({
				color: '#0000ff'
			})
		})
	})
});

streams_layer = new ol.layer.Vector({
	source: new ol.source.Vector(),
	style: new ol.style.Style({
		fill: new ol.style.Fill({
			color: 'rgba(0,0,255,0.6)'
		}),
		stroke: new ol.style.Stroke({
			color: '#0000ff',
			width: 2
		}),
		image: new ol.style.Circle({
			radius: 5,
			fill: new ol.style.Fill({
				color: '#0000ff'
			})
		})
	})
});

map.addLayer(click_point_layer);
map.addLayer(start_point_layer);
map.addLayer(end_point_layer);
map.addLayer(indexing_path_layer);
map.addLayer(flow_lines_layer);
map.addLayer(basin_layer);
map.addLayer(streams_layer);

map.on('click', function(evt) {
        flag_geocoded=false;
        var coordinate = evt.coordinate;
        addClickPoint(coordinate);
        var lonlat = ol.proj.transform(coordinate, 'EPSG:3857', 'EPSG:4326');
        //Each time the user clicks on the map, let's run the point
        //indexing service to show them the closest NHD reach segment.
        run_point_indexing_service(lonlat);
    })

function addClickPoint(coordinates){
    // Check if the feature exists. If not then create it.
    // If it does exist, then just change its geometry to the new coords.
    var geometry = new ol.geom.Point(coordinates);
    if (click_point_layer.getSource().getFeatures().length==0){
        var feature = new ol.Feature({
            geometry: geometry,
            attr: 'Some Property'
        });
        click_point_layer.getSource().addFeature(feature);
    } else {
        click_point_layer.getSource().getFeatures()[0].setGeometry(geometry);
    }
}


function CenterMap(lat,lon){
    var dbPoint = {
        "type": "Point",
        "coordinates": [lon, lat]
    }
    var coords = ol.proj.transform(dbPoint.coordinates, 'EPSG:4326','EPSG:3857');
    map.getView().setCenter(coords);
}

function clear_location_layers() {
    start_point_layer.getSource().clear();
    end_point_layer.getSource().clear();
    indexing_path_layer.getSource().clear();
    flow_lines_layer.getSource().clear();
    basin_layer.getSource().clear();
    streams_layer.getSource().clear();
}

//Functions for working with EPA WATERS web services
//Search button, function if point indexing service
function run_point_indexing_service(lonlat) {
    var inputLon = lonlat[0];
    var inputLat = lonlat[1];
    var wktval = "POINT(" + inputLon + " " + inputLat + ")";

    var options = {
        "success" : "pis_success",
        "error"   : "pis_error",
        "timeout" : 60 * 1000
    };

    var data = {
        "pGeometry": wktval,
        "pGeometryMod": "WKT,SRSNAME=urn:ogc:def:crs:OGC::CRS84",
        "pPointIndexingMethod": "DISTANCE",
        "pPointIndexingMaxDist": 10,
        "pOutputPathFlag": "TRUE",
        "pReturnFlowlineGeomFlag": "FULL",
        "optOutCS": "SRSNAME=urn:ogc:def:crs:OGC::CRS84",
        "optOutPrettyPrint": 0,
        "optClientRef": "CodePen"
    };
	clear_location_layers();
    rtnStr = WATERS.Services.PointIndexingService(data, options);
    // The service runs and when it is done, it will call either the
    // success or error functions. So the actual actions upon success all
    // happen in the success function.
}

function pis_success(result, textStatus) {
    var srv_rez = result.output;
    if (srv_rez == null) {
        if ( result.status.status_message !== null ) {
            report_failed_search(result.status.status_message);
        } else {
            report_failed_search("No results found");
        }
        return;
    }

    //add the found start point, end point, indexing path, and flow line to the map
    //clear_location_layers();
    start_point_layer.getSource().addFeature(geojson2feature(srv_rez.start_point));
    end_point_layer.getSource().addFeature(geojson2feature(srv_rez.end_point));
    indexing_path_layer.getSource().addFeature(geojson2feature(srv_rez.indexing_path));

	srv_fl = result.output.ary_flowlines;
	comid = srv_fl[0].comid.toString();
    fmeasure = srv_fl[0].fmeasure.toFixed(2).toString();

    for (i in srv_fl){
        flow_lines_layer.getSource().addFeature(geojson2feature(srv_fl[i].shape));
    }

    var coord = end_point_layer.getSource().getFeatures()[0].getGeometry().getCoordinates();
    var LLcoord = ol.proj.transform(coord,'EPSG:3857','EPSG:4326');

    //get a little closer if we are zoomed way out.
    if (map.getView().getZoom()<12) {
        map.getView().setZoom(12);
        CenterMap(LLcoord[1],LLcoord[0]);
    }
}

function pis_error(XMLHttpRequest, textStatus, errorThrown) {
    report_failed_search(textStatus);
}

function report_failed_search(MessageText){
	document.getElementById("delineation_output").innerHTML = "<strong>Search Error:</strong><br>" + textMessage;
}

function geojson2feature(myGeoJSON) {
    //Convert GeoJSON object into an OpenLayers 3 feature.
    //Also force jquery coordinates into real js Array if needed
    var geojsonformatter = new ol.format.GeoJSON;
    if (myGeoJSON.coordinates instanceof Array == false) {
        myGeoJSON.coordinates = WATERS.Utilities.RepairArray(myGeoJSON.coordinates,0);
    }
    var myGeometry = geojsonformatter.readGeometry(myGeoJSON);
    myGeometry.transform('EPSG:4326','EPSG:3857');
    var myFeature = new ol.Feature(myGeometry);
    return myFeature;
}

function run_navigation_delineation_service(){
    var options = {
        "success": "nds_success",
        "error": "nds_error",
        "timeout": 60 * 1000,
        "geomFormat": "GEOJSON"
    };

    var data = {
        "pNavigationType": "UT",
        "pStartComid": comid,
        "pStartMeasure": fmeasure,
        "pMaxDistance": 1000,
        "pAggregationFlag": "TRUE",
        "pFeatureType": "CATCHMENT",
        "pOutputFlag": "BOTH",
        "optNHDPlusDataset": "2.1"
    };
	waiting_note();
    rtnStr = WATERS.Services.NavigationDelineationService(data, options);
    //this will start the service. If it succeeds, it will call nds_success.
}

function nds_success(result, textStatus) {

	document.getElementById("delineation_output").innerHTML = '';

    var srv_rez = result.output;

    if (srv_rez == null) {
        if (result.status.status_message !== null) {
            report_failed_delineation(result.status.status_message);
        } else {
            report_failed_delineation("No results found");
        }
    } else {

        streams_layer.getSource().clear();
        basin_layer.getSource().clear();

        if (result.output.shape == null) {
            for (i in result.output.catchments) {
                basin_layer.getSource().addFeature(geojson2feature(result.output.catchments[i].shape));
            }
        } else {
            basin_layer.getSource().addFeature(geojson2feature(result.output.shape));
        }

        if (result.output.flowlines.length > 0) {
            for (i in result.output.flowlines) {
                streams_layer.getSource().addFeature(geojson2feature(result.output.flowlines[i].shape));
            }
        }
        map.getView().fit(basin_layer.getSource().getExtent(), map.getSize());
    }

}

function nds_error(XMLHttpRequest, textStatus, errorThrown) {
    report_failed_delineation(textStatus);
}

function report_failed_delineation(textMessage) {
    document.getElementById("delineation_output").innerHTML = "<strong>Delineation Error:</strong><br>" + textMessage;
}

function waiting_note() {
    var wait_text = "<strong>Loading...</strong><br>" +
        "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src='http://netanimations.net/spinning_earth_globe_3.gif'>";
    document.getElementById('delineation_output').innerHTML = wait_text;
}

    </script>
</body>
</html>